{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SrvPoller = exports.SrvPollingEvent = void 0;\n\nvar dns = require(\"dns\");\n\nvar logger_1 = require(\"../logger\");\n\nvar utils_1 = require(\"../utils\");\n\nvar mongo_types_1 = require(\"../mongo_types\");\n\nvar error_1 = require(\"../error\");\n/**\n * Determines whether a provided address matches the provided parent domain in order\n * to avoid certain attack vectors.\n *\n * @param srvAddress - The address to check against a domain\n * @param parentDomain - The domain to check the provided address against\n * @returns Whether the provided address matches the parent domain\n */\n\n\nfunction matchesParentDomain(srvAddress, parentDomain) {\n  var regex = /^.*?\\./;\n  var srv = \".\".concat(srvAddress.replace(regex, ''));\n  var parent = \".\".concat(parentDomain.replace(regex, ''));\n  return srv.endsWith(parent);\n}\n/**\n * @internal\n * @category Event\n */\n\n\nvar SrvPollingEvent = /*#__PURE__*/function () {\n  function SrvPollingEvent(srvRecords) {\n    _classCallCheck(this, SrvPollingEvent);\n\n    this.srvRecords = srvRecords;\n  }\n\n  _createClass(SrvPollingEvent, [{\n    key: \"hostnames\",\n    value: function hostnames() {\n      return new Set(this.srvRecords.map(function (r) {\n        return utils_1.HostAddress.fromSrvRecord(r).toString();\n      }));\n    }\n  }]);\n\n  return SrvPollingEvent;\n}();\n\nexports.SrvPollingEvent = SrvPollingEvent;\n/** @internal */\n\nvar SrvPoller = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(SrvPoller, _mongo_types_1$TypedE);\n\n  function SrvPoller(options) {\n    var _this;\n\n    _classCallCheck(this, SrvPoller);\n\n    var _a, _b, _c;\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SrvPoller).call(this));\n\n    if (!options || !options.srvHost) {\n      throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');\n    }\n\n    _this.srvHost = options.srvHost;\n    _this.srvMaxHosts = (_a = options.srvMaxHosts) !== null && _a !== void 0 ? _a : 0;\n    _this.srvServiceName = (_b = options.srvServiceName) !== null && _b !== void 0 ? _b : 'mongodb';\n    _this.rescanSrvIntervalMS = 60000;\n    _this.heartbeatFrequencyMS = (_c = options.heartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 10000;\n    _this.logger = new logger_1.Logger('srvPoller', options);\n    _this.haMode = false;\n    _this.generation = 0;\n    _this._timeout = undefined;\n    return _this;\n  }\n\n  _createClass(SrvPoller, [{\n    key: \"start\",\n    value: function start() {\n      if (!this._timeout) {\n        this.schedule();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n        this.generation += 1;\n        this._timeout = undefined;\n      }\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule() {\n      var _this2 = this;\n\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n\n      this._timeout = setTimeout(function () {\n        return _this2._poll();\n      }, this.intervalMS);\n    }\n  }, {\n    key: \"success\",\n    value: function success(srvRecords) {\n      this.haMode = false;\n      this.schedule();\n      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));\n    }\n  }, {\n    key: \"failure\",\n    value: function failure(message, obj) {\n      this.logger.warn(message, obj);\n      this.haMode = true;\n      this.schedule();\n    }\n  }, {\n    key: \"parentDomainMismatch\",\n    value: function parentDomainMismatch(srvRecord) {\n      this.logger.warn(\"parent domain mismatch on SRV record (\".concat(srvRecord.name, \":\").concat(srvRecord.port, \")\"), srvRecord);\n    }\n  }, {\n    key: \"_poll\",\n    value: function _poll() {\n      var _this3 = this;\n\n      var generation = this.generation;\n      dns.resolveSrv(this.srvAddress, function (err, srvRecords) {\n        if (generation !== _this3.generation) {\n          return;\n        }\n\n        if (err) {\n          _this3.failure('DNS error', err);\n\n          return;\n        }\n\n        var finalAddresses = [];\n\n        var _iterator = _createForOfIteratorHelper(srvRecords),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var record = _step.value;\n\n            if (matchesParentDomain(record.name, _this3.srvHost)) {\n              finalAddresses.push(record);\n            } else {\n              _this3.parentDomainMismatch(record);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!finalAddresses.length) {\n          _this3.failure('No valid addresses found at host');\n\n          return;\n        }\n\n        _this3.success(finalAddresses);\n      });\n    }\n  }, {\n    key: \"srvAddress\",\n    get: function get() {\n      return \"_\".concat(this.srvServiceName, \"._tcp.\").concat(this.srvHost);\n    }\n  }, {\n    key: \"intervalMS\",\n    get: function get() {\n      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;\n    }\n  }]);\n\n  return SrvPoller;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.SrvPoller = SrvPoller;\n/** @event */\n\nSrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';","map":null,"metadata":{},"sourceType":"script"}