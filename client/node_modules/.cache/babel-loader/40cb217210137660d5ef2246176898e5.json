{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _defineProperty = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _ref;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServerCapabilities = exports.TOPOLOGY_EVENTS = exports.Topology = void 0;\n\nvar Denque = require(\"denque\");\n\nvar read_preference_1 = require(\"../read_preference\");\n\nvar server_description_1 = require(\"./server_description\");\n\nvar topology_description_1 = require(\"./topology_description\");\n\nvar server_1 = require(\"./server\");\n\nvar sessions_1 = require(\"../sessions\");\n\nvar srv_polling_1 = require(\"./srv_polling\");\n\nvar connection_pool_1 = require(\"../cmap/connection_pool\");\n\nvar error_1 = require(\"../error\");\n\nvar server_selection_1 = require(\"./server_selection\");\n\nvar utils_1 = require(\"../utils\");\n\nvar common_1 = require(\"./common\");\n\nvar events_1 = require(\"./events\");\n\nvar connection_1 = require(\"../cmap/connection\");\n\nvar connection_string_1 = require(\"../connection_string\");\n\nvar bson_1 = require(\"../bson\");\n\nvar mongo_types_1 = require(\"../mongo_types\"); // Global state\n\n\nvar globalTopologyCounter = 0; // events that we relay to the `Topology`\n\nvar SERVER_RELAY_EVENTS = [server_1.Server.SERVER_HEARTBEAT_STARTED, server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, server_1.Server.SERVER_HEARTBEAT_FAILED, connection_1.Connection.COMMAND_STARTED, connection_1.Connection.COMMAND_SUCCEEDED, connection_1.Connection.COMMAND_FAILED].concat(_toConsumableArray(connection_pool_1.CMAP_EVENTS)); // all events we listen to from `Server` instances\n\nvar LOCAL_SERVER_EVENTS = [server_1.Server.CONNECT, server_1.Server.DESCRIPTION_RECEIVED, server_1.Server.CLOSED, server_1.Server.ENDED];\nvar stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));\n/** @internal */\n\nvar kCancelled = Symbol('cancelled');\n/** @internal */\n\nvar kWaitQueue = Symbol('waitQueue');\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n * @internal\n */\n\nvar Topology = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Topology, _mongo_types_1$TypedE);\n\n  /**\n   * @param seedlist - a list of HostAddress instances to connect to\n   */\n  function Topology(seeds, options) {\n    var _this;\n\n    _classCallCheck(this, Topology);\n\n    var _a;\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Topology).call(this)); // Legacy CSFLE support\n\n    _this.bson = Object.create(null);\n    _this.bson.serialize = bson_1.serialize;\n    _this.bson.deserialize = bson_1.deserialize; // Options should only be undefined in tests, MongoClient will always have defined options\n\n    options = options !== null && options !== void 0 ? options : {\n      hosts: [utils_1.HostAddress.fromString('localhost:27017')],\n      retryReads: connection_string_1.DEFAULT_OPTIONS.get('retryReads'),\n      retryWrites: connection_string_1.DEFAULT_OPTIONS.get('retryWrites'),\n      serverSelectionTimeoutMS: connection_string_1.DEFAULT_OPTIONS.get('serverSelectionTimeoutMS'),\n      directConnection: connection_string_1.DEFAULT_OPTIONS.get('directConnection'),\n      loadBalanced: connection_string_1.DEFAULT_OPTIONS.get('loadBalanced'),\n      metadata: connection_string_1.DEFAULT_OPTIONS.get('metadata'),\n      monitorCommands: connection_string_1.DEFAULT_OPTIONS.get('monitorCommands'),\n      tls: connection_string_1.DEFAULT_OPTIONS.get('tls'),\n      maxPoolSize: connection_string_1.DEFAULT_OPTIONS.get('maxPoolSize'),\n      minPoolSize: connection_string_1.DEFAULT_OPTIONS.get('minPoolSize'),\n      waitQueueTimeoutMS: connection_string_1.DEFAULT_OPTIONS.get('waitQueueTimeoutMS'),\n      connectionType: connection_string_1.DEFAULT_OPTIONS.get('connectionType'),\n      connectTimeoutMS: connection_string_1.DEFAULT_OPTIONS.get('connectTimeoutMS'),\n      maxIdleTimeMS: connection_string_1.DEFAULT_OPTIONS.get('maxIdleTimeMS'),\n      heartbeatFrequencyMS: connection_string_1.DEFAULT_OPTIONS.get('heartbeatFrequencyMS'),\n      minHeartbeatFrequencyMS: connection_string_1.DEFAULT_OPTIONS.get('minHeartbeatFrequencyMS')\n    };\n\n    if (typeof seeds === 'string') {\n      seeds = [utils_1.HostAddress.fromString(seeds)];\n    } else if (!Array.isArray(seeds)) {\n      seeds = [seeds];\n    }\n\n    var seedlist = [];\n\n    var _iterator = _createForOfIteratorHelper(seeds),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var seed = _step.value;\n\n        if (typeof seed === 'string') {\n          seedlist.push(utils_1.HostAddress.fromString(seed));\n        } else if (seed instanceof utils_1.HostAddress) {\n          seedlist.push(seed);\n        } else {\n          // FIXME(NODE-3483): May need to be a MongoParseError\n          throw new error_1.MongoRuntimeError(\"Topology cannot be constructed from \".concat(JSON.stringify(seed)));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var topologyType = topologyTypeFromOptions(options);\n    var topologyId = globalTopologyCounter++;\n    var selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);\n    var serverDescriptions = new Map();\n\n    var _iterator2 = _createForOfIteratorHelper(selectedHosts),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var hostAddress = _step2.value;\n        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    _this[kWaitQueue] = new Denque();\n    _this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options: options,\n      // initial seedlist of servers to connect to\n      seedlist: seedlist,\n      // initial state\n      state: common_1.STATE_CLOSED,\n      // the topology description\n      description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      // Server Session Pool\n      sessionPool: new sessions_1.ServerSessionPool(_assertThisInitialized(_assertThisInitialized(_this))),\n      // Active client sessions\n      sessions: new Set(),\n      credentials: options === null || options === void 0 ? void 0 : options.credentials,\n      clusterTime: undefined,\n      // timer management\n      connectionTimers: new Set(),\n      detectShardedTopology: function detectShardedTopology(ev) {\n        return _this.detectShardedTopology(ev);\n      },\n      detectSrvRecords: function detectSrvRecords(ev) {\n        return _this.detectSrvRecords(ev);\n      }\n    };\n\n    if (options.srvHost && !options.loadBalanced) {\n      _this.s.srvPoller = (_a = options.srvPoller) !== null && _a !== void 0 ? _a : new srv_polling_1.SrvPoller({\n        heartbeatFrequencyMS: _this.s.heartbeatFrequencyMS,\n        srvHost: options.srvHost,\n        srvMaxHosts: options.srvMaxHosts,\n        srvServiceName: options.srvServiceName\n      });\n\n      _this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this.s.detectShardedTopology);\n    }\n\n    return _this;\n  }\n\n  _createClass(Topology, [{\n    key: \"detectShardedTopology\",\n    value: function detectShardedTopology(event) {\n      var _a, _b, _c;\n\n      var previousType = event.previousDescription.type;\n      var newType = event.newDescription.type;\n      var transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;\n      var srvListeners = (_a = this.s.srvPoller) === null || _a === void 0 ? void 0 : _a.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);\n      var listeningToSrvPolling = !!(srvListeners === null || srvListeners === void 0 ? void 0 : srvListeners.includes(this.s.detectSrvRecords));\n\n      if (transitionToSharded && !listeningToSrvPolling) {\n        (_b = this.s.srvPoller) === null || _b === void 0 ? void 0 : _b.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n        (_c = this.s.srvPoller) === null || _c === void 0 ? void 0 : _c.start();\n      }\n    }\n  }, {\n    key: \"detectSrvRecords\",\n    value: function detectSrvRecords(ev) {\n      var previousTopologyDescription = this.s.description;\n      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);\n\n      if (this.s.description === previousTopologyDescription) {\n        // Nothing changed, so return\n        return;\n      }\n\n      updateServers(this);\n      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n    }\n    /**\n     * @returns A `TopologyDescription` for this topology\n     */\n\n  }, {\n    key: \"connect\",\n\n    /** Initiate server connect */\n    value: function connect(options, callback) {\n      var _this2 = this;\n\n      var _a;\n\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n\n      if (this.s.state === common_1.STATE_CONNECTED) {\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      stateTransition(this, common_1.STATE_CONNECTING); // emit SDAM monitoring events\n\n      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id)); // emit an event for the topology change\n\n      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), // initial is always Unknown\n      this.s.description)); // connect all known servers, then attempt server selection to connect\n\n      var serverDescriptions = Array.from(this.s.description.servers.values());\n      connectServers(this, serverDescriptions); // In load balancer mode we need to fake a server description getting\n      // emitted from the monitor, since the monitor doesn't exist.\n\n      if (this.s.options.loadBalanced) {\n        var _iterator3 = _createForOfIteratorHelper(serverDescriptions),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var description = _step3.value;\n            var newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {\n              loadBalanced: this.s.options.loadBalanced\n            });\n            this.serverUpdateHandler(newDescription);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      var readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, function (err, server) {\n        if (err) {\n          _this2.close();\n\n          typeof callback === 'function' ? callback(err) : _this2.emit(Topology.ERROR, err);\n          return;\n        } // TODO: NODE-2471\n\n\n        if (server && _this2.s.credentials) {\n          server.command((0, utils_1.ns)('admin.$cmd'), {\n            ping: 1\n          }, function (err) {\n            if (err) {\n              typeof callback === 'function' ? callback(err) : _this2.emit(Topology.ERROR, err);\n              return;\n            }\n\n            stateTransition(_this2, common_1.STATE_CONNECTED);\n\n            _this2.emit(Topology.OPEN, _this2);\n\n            _this2.emit(Topology.CONNECT, _this2);\n\n            if (typeof callback === 'function') callback(undefined, _this2);\n          });\n          return;\n        }\n\n        stateTransition(_this2, common_1.STATE_CONNECTED);\n\n        _this2.emit(Topology.OPEN, _this2);\n\n        _this2.emit(Topology.CONNECT, _this2);\n\n        if (typeof callback === 'function') callback(undefined, _this2);\n      });\n    }\n    /** Close this topology */\n\n  }, {\n    key: \"close\",\n    value: function close(options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof options === 'boolean') {\n        options = {\n          force: options\n        };\n      }\n\n      options = options !== null && options !== void 0 ? options : {};\n\n      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      stateTransition(this, common_1.STATE_CLOSING);\n      drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError());\n      (0, common_1.drainTimerQueue)(this.s.connectionTimers);\n\n      if (this.s.srvPoller) {\n        this.s.srvPoller.stop();\n        this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n      }\n\n      this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);\n      (0, utils_1.eachAsync)(Array.from(this.s.sessions.values()), function (session, cb) {\n        return session.endSession(cb);\n      }, function () {\n        _this3.s.sessionPool.endAllPooledSessions(function () {\n          (0, utils_1.eachAsync)(Array.from(_this3.s.servers.values()), function (server, cb) {\n            return destroyServer(server, _this3, options, cb);\n          }, function (err) {\n            _this3.s.servers.clear(); // emit an event for close\n\n\n            _this3.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(_this3.s.id));\n\n            stateTransition(_this3, common_1.STATE_CLOSED);\n\n            if (typeof callback === 'function') {\n              callback(err);\n            }\n          });\n        });\n      });\n    }\n  }, {\n    key: \"selectServer\",\n    value: function selectServer(selector, _options, _callback) {\n      var _this4 = this;\n\n      var options = _options;\n      var callback = _callback !== null && _callback !== void 0 ? _callback : _options;\n\n      if (typeof options === 'function') {\n        options = {};\n      }\n\n      var serverSelector;\n\n      if (typeof selector !== 'function') {\n        if (typeof selector === 'string') {\n          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));\n        } else {\n          var readPreference;\n\n          if (selector instanceof read_preference_1.ReadPreference) {\n            readPreference = selector;\n          } else {\n            read_preference_1.ReadPreference.translate(options);\n            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;\n          }\n\n          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);\n        }\n      } else {\n        serverSelector = selector;\n      }\n\n      options = Object.assign({}, {\n        serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS\n      }, options);\n      var isSharded = this.description.type === common_1.TopologyType.Sharded;\n      var session = options.session;\n      var transaction = session && session.transaction;\n\n      if (isSharded && transaction && transaction.server) {\n        callback(undefined, transaction.server);\n        return;\n      }\n\n      var waitQueueMember = {\n        serverSelector: serverSelector,\n        transaction: transaction,\n        callback: callback\n      };\n      var serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n\n      if (serverSelectionTimeoutMS) {\n        waitQueueMember.timer = setTimeout(function () {\n          waitQueueMember[kCancelled] = true;\n          waitQueueMember.timer = undefined;\n          var timeoutError = new error_1.MongoServerSelectionError(\"Server selection timed out after \".concat(serverSelectionTimeoutMS, \" ms\"), _this4.description);\n          waitQueueMember.callback(timeoutError);\n        }, serverSelectionTimeoutMS);\n      }\n\n      this[kWaitQueue].push(waitQueueMember);\n      processWaitQueue(this);\n    } // Sessions related methods\n\n    /**\n     * @returns Whether the topology should initiate selection to determine session support\n     */\n\n  }, {\n    key: \"shouldCheckForSessionSupport\",\n    value: function shouldCheckForSessionSupport() {\n      if (this.description.type === common_1.TopologyType.Single) {\n        return !this.description.hasKnownServers;\n      }\n\n      return !this.description.hasDataBearingServers;\n    }\n    /**\n     * @returns Whether sessions are supported on the current topology\n     */\n\n  }, {\n    key: \"hasSessionSupport\",\n    value: function hasSessionSupport() {\n      return this.loadBalanced || this.description.logicalSessionTimeoutMinutes != null;\n    }\n    /** Start a logical session */\n\n  }, {\n    key: \"startSession\",\n    value: function startSession(options, clientOptions) {\n      var _this5 = this;\n\n      var session = new sessions_1.ClientSession(this, this.s.sessionPool, options, clientOptions);\n      session.once('ended', function () {\n        _this5.s.sessions.delete(session);\n      });\n      this.s.sessions.add(session);\n      return session;\n    }\n    /** Send endSessions command(s) with the given session ids */\n\n  }, {\n    key: \"endSessions\",\n    value: function endSessions(sessions, callback) {\n      if (!Array.isArray(sessions)) {\n        sessions = [sessions];\n      }\n\n      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred), function (err, server) {\n        if (err || !server) {\n          if (typeof callback === 'function') callback(err);\n          return;\n        }\n\n        server.command((0, utils_1.ns)('admin.$cmd'), {\n          endSessions: sessions\n        }, {\n          noResponse: true\n        }, function (err, result) {\n          if (typeof callback === 'function') callback(err, result);\n        });\n      });\n    }\n    /**\n     * Update the internal TopologyDescription with a ServerDescription\n     *\n     * @param serverDescription - The server to update in the internal list of server descriptions\n     */\n\n  }, {\n    key: \"serverUpdateHandler\",\n    value: function serverUpdateHandler(serverDescription) {\n      if (!this.s.description.hasServer(serverDescription.address)) {\n        return;\n      } // ignore this server update if its from an outdated topologyVersion\n\n\n      if (isStaleServerDescription(this.s.description, serverDescription)) {\n        return;\n      } // these will be used for monitoring events later\n\n\n      var previousTopologyDescription = this.s.description;\n      var previousServerDescription = this.s.description.servers.get(serverDescription.address);\n\n      if (!previousServerDescription) {\n        return;\n      } // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n      // a server it MUST compare it to the current highest seen cluster time\n      // for the deployment. If the new cluster time is higher than the\n      // highest seen cluster time it MUST become the new highest seen cluster\n      // time. Two cluster times are compared using only the BsonTimestamp\n      // value of the clusterTime embedded field.\"\n\n\n      var clusterTime = serverDescription.$clusterTime;\n\n      if (clusterTime) {\n        (0, common_1._advanceClusterTime)(this, clusterTime);\n      } // If we already know all the information contained in this updated description, then\n      // we don't need to emit SDAM events, but still need to update the description, in order\n      // to keep client-tracked attributes like last update time and round trip time up to date\n\n\n      var equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription); // first update the TopologyDescription\n\n      this.s.description = this.s.description.update(serverDescription);\n\n      if (this.s.description.compatibilityError) {\n        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));\n        return;\n      } // emit monitoring events for this change\n\n\n      if (!equalDescriptions) {\n        var newDescription = this.s.description.servers.get(serverDescription.address);\n\n        if (newDescription) {\n          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));\n        }\n      } // update server list from updated descriptions\n\n\n      updateServers(this, serverDescription); // attempt to resolve any outstanding server selection attempts\n\n      if (this[kWaitQueue].length > 0) {\n        processWaitQueue(this);\n      }\n\n      if (!equalDescriptions) {\n        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n      }\n    }\n  }, {\n    key: \"auth\",\n    value: function auth(credentials, callback) {\n      if (typeof credentials === 'function') callback = credentials, credentials = undefined;\n      if (typeof callback === 'function') callback(undefined, true);\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.s.state === common_1.STATE_CONNECTED;\n    }\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this.s.state === common_1.STATE_CLOSED;\n    }\n    /**\n     * @deprecated This function is deprecated and will be removed in the next major version.\n     */\n\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      (0, utils_1.emitWarning)('`unref` is a noop and will be removed in the next major version');\n    } // NOTE: There are many places in code where we explicitly check the last isMaster\n    //       to do feature support detection. This should be done any other way, but for\n    //       now we will just return the first isMaster seen, which should suffice.\n\n  }, {\n    key: \"lastIsMaster\",\n    value: function lastIsMaster() {\n      var serverDescriptions = Array.from(this.description.servers.values());\n      if (serverDescriptions.length === 0) return {};\n      var sd = serverDescriptions.filter(function (sd) {\n        return sd.type !== common_1.ServerType.Unknown;\n      })[0];\n      var result = sd || {\n        maxWireVersion: this.description.commonWireVersion\n      };\n      return result;\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this.s.description;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.s.options.loadBalanced;\n    }\n  }, {\n    key: \"capabilities\",\n    get: function get() {\n      return new ServerCapabilities(this.lastIsMaster());\n    }\n  }, {\n    key: \"clientMetadata\",\n    get: function get() {\n      return this.s.options.metadata;\n    }\n  }, {\n    key: \"commonWireVersion\",\n    get: function get() {\n      return this.description.commonWireVersion;\n    }\n  }, {\n    key: \"logicalSessionTimeoutMinutes\",\n    get: function get() {\n      return this.description.logicalSessionTimeoutMinutes;\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this.s.clusterTime;\n    },\n    set: function set(clusterTime) {\n      this.s.clusterTime = clusterTime;\n    }\n  }]);\n\n  return Topology;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.Topology = Topology;\n/** @event */\n\nTopology.SERVER_OPENING = 'serverOpening';\n/** @event */\n\nTopology.SERVER_CLOSED = 'serverClosed';\n/** @event */\n\nTopology.SERVER_DESCRIPTION_CHANGED = 'serverDescriptionChanged';\n/** @event */\n\nTopology.TOPOLOGY_OPENING = 'topologyOpening';\n/** @event */\n\nTopology.TOPOLOGY_CLOSED = 'topologyClosed';\n/** @event */\n\nTopology.TOPOLOGY_DESCRIPTION_CHANGED = 'topologyDescriptionChanged';\n/** @event */\n\nTopology.ERROR = 'error';\n/** @event */\n\nTopology.OPEN = 'open';\n/** @event */\n\nTopology.CONNECT = 'connect';\n/** @event */\n\nTopology.CLOSE = 'close';\n/** @event */\n\nTopology.TIMEOUT = 'timeout';\n/** @public */\n\nexports.TOPOLOGY_EVENTS = [Topology.SERVER_OPENING, Topology.SERVER_CLOSED, Topology.SERVER_DESCRIPTION_CHANGED, Topology.TOPOLOGY_OPENING, Topology.TOPOLOGY_CLOSED, Topology.TOPOLOGY_DESCRIPTION_CHANGED, Topology.ERROR, Topology.TIMEOUT, Topology.CLOSE];\n/** Destroys a server, and removes all event listeners from the instance */\n\nfunction destroyServer(server, topology, options, callback) {\n  options = options !== null && options !== void 0 ? options : {};\n\n  var _iterator4 = _createForOfIteratorHelper(LOCAL_SERVER_EVENTS),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var event = _step4.value;\n      server.removeAllListeners(event);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  server.destroy(options, function () {\n    topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));\n\n    var _iterator5 = _createForOfIteratorHelper(SERVER_RELAY_EVENTS),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var event = _step5.value;\n        server.removeAllListeners(event);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n}\n/** Predicts the TopologyType from options */\n\n\nfunction topologyTypeFromOptions(options) {\n  if (options === null || options === void 0 ? void 0 : options.directConnection) {\n    return common_1.TopologyType.Single;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.replicaSet) {\n    return common_1.TopologyType.ReplicaSetNoPrimary;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {\n    return common_1.TopologyType.LoadBalanced;\n  }\n\n  return common_1.TopologyType.Unknown;\n}\n\nfunction randomSelection(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}\n/**\n * Creates new server instances and attempts to connect them\n *\n * @param topology - The topology that this server belongs to\n * @param serverDescription - The description for the server to initialize and connect to\n * @param connectDelay - Time to wait before attempting initial connection\n */\n\n\nfunction createAndConnectServer(topology, serverDescription, connectDelay) {\n  topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));\n  var server = new server_1.Server(topology, serverDescription, topology.s.options);\n\n  var _iterator6 = _createForOfIteratorHelper(SERVER_RELAY_EVENTS),\n      _step6;\n\n  try {\n    var _loop = function _loop() {\n      var event = _step6.value;\n      server.on(event, function (e) {\n        return topology.emit(event, e);\n      });\n    };\n\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  server.on(server_1.Server.DESCRIPTION_RECEIVED, function (description) {\n    return topology.serverUpdateHandler(description);\n  });\n\n  if (connectDelay) {\n    var connectTimer = setTimeout(function () {\n      (0, common_1.clearAndRemoveTimerFrom)(connectTimer, topology.s.connectionTimers);\n      server.connect();\n    }, connectDelay);\n    topology.s.connectionTimers.add(connectTimer);\n    return server;\n  }\n\n  server.connect();\n  return server;\n}\n/**\n * Create `Server` instances for all initially known servers, connect them, and assign\n * them to the passed in `Topology`.\n *\n * @param topology - The topology responsible for the servers\n * @param serverDescriptions - A list of server descriptions to connect\n */\n\n\nfunction connectServers(topology, serverDescriptions) {\n  topology.s.servers = serverDescriptions.reduce(function (servers, serverDescription) {\n    var server = createAndConnectServer(topology, serverDescription);\n    servers.set(serverDescription.address, server);\n    return servers;\n  }, new Map());\n}\n/**\n * @param topology - Topology to update.\n * @param incomingServerDescription - New server description.\n */\n\n\nfunction updateServers(topology, incomingServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    var server = topology.s.servers.get(incomingServerDescription.address);\n\n    if (server) {\n      server.s.description = incomingServerDescription;\n    }\n  } // add new servers for all descriptions we currently don't know about locally\n\n\n  var _iterator7 = _createForOfIteratorHelper(topology.description.servers.values()),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var serverDescription = _step7.value;\n\n      if (!topology.s.servers.has(serverDescription.address)) {\n        var _server = createAndConnectServer(topology, serverDescription);\n\n        topology.s.servers.set(serverDescription.address, _server);\n      }\n    } // for all servers no longer known, remove their descriptions and destroy their instances\n\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  var _iterator8 = _createForOfIteratorHelper(topology.s.servers),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var entry = _step8.value;\n      var serverAddress = entry[0];\n\n      if (topology.description.hasServer(serverAddress)) {\n        continue;\n      }\n\n      if (!topology.s.servers.has(serverAddress)) {\n        continue;\n      }\n\n      var _server2 = topology.s.servers.get(serverAddress);\n\n      topology.s.servers.delete(serverAddress); // prepare server for garbage collection\n\n      if (_server2) {\n        destroyServer(_server2, topology);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\n\nfunction drainWaitQueue(queue, err) {\n  while (queue.length) {\n    var waitQueueMember = queue.shift();\n\n    if (!waitQueueMember) {\n      continue;\n    }\n\n    if (waitQueueMember.timer) {\n      clearTimeout(waitQueueMember.timer);\n    }\n\n    if (!waitQueueMember[kCancelled]) {\n      waitQueueMember.callback(err);\n    }\n  }\n}\n\nfunction processWaitQueue(topology) {\n  if (topology.s.state === common_1.STATE_CLOSED) {\n    drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());\n    return;\n  }\n\n  var isSharded = topology.description.type === common_1.TopologyType.Sharded;\n  var serverDescriptions = Array.from(topology.description.servers.values());\n  var membersToProcess = topology[kWaitQueue].length;\n\n  for (var i = 0; i < membersToProcess; ++i) {\n    var waitQueueMember = topology[kWaitQueue].shift();\n\n    if (!waitQueueMember) {\n      continue;\n    }\n\n    if (waitQueueMember[kCancelled]) {\n      continue;\n    }\n\n    var selectedDescriptions = void 0;\n\n    try {\n      var serverSelector = waitQueueMember.serverSelector;\n      selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;\n    } catch (e) {\n      if (waitQueueMember.timer) {\n        clearTimeout(waitQueueMember.timer);\n      }\n\n      waitQueueMember.callback(e);\n      continue;\n    }\n\n    if (selectedDescriptions.length === 0) {\n      topology[kWaitQueue].push(waitQueueMember);\n      continue;\n    }\n\n    var selectedServerDescription = randomSelection(selectedDescriptions);\n    var selectedServer = topology.s.servers.get(selectedServerDescription.address);\n    var transaction = waitQueueMember.transaction;\n\n    if (isSharded && transaction && transaction.isActive && selectedServer) {\n      transaction.pinServer(selectedServer);\n    }\n\n    if (waitQueueMember.timer) {\n      clearTimeout(waitQueueMember.timer);\n    }\n\n    waitQueueMember.callback(undefined, selectedServer);\n  }\n\n  if (topology[kWaitQueue].length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    var _iterator9 = _createForOfIteratorHelper(topology.s.servers),\n        _step9;\n\n    try {\n      var _loop2 = function _loop2() {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n            server = _step9$value[1];\n\n        process.nextTick(function scheduleServerCheck() {\n          return server.requestCheck();\n        });\n      };\n\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n}\n\nfunction isStaleServerDescription(topologyDescription, incomingServerDescription) {\n  var currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);\n  var currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;\n  return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;\n}\n/** @public */\n\n\nvar ServerCapabilities = /*#__PURE__*/function () {\n  function ServerCapabilities(ismaster) {\n    _classCallCheck(this, ServerCapabilities);\n\n    this.minWireVersion = ismaster.minWireVersion || 0;\n    this.maxWireVersion = ismaster.maxWireVersion || 0;\n  }\n\n  _createClass(ServerCapabilities, [{\n    key: \"hasAggregationCursor\",\n    get: function get() {\n      return this.maxWireVersion >= 1;\n    }\n  }, {\n    key: \"hasWriteCommands\",\n    get: function get() {\n      return this.maxWireVersion >= 2;\n    }\n  }, {\n    key: \"hasTextSearch\",\n    get: function get() {\n      return this.minWireVersion >= 0;\n    }\n  }, {\n    key: \"hasAuthCommands\",\n    get: function get() {\n      return this.maxWireVersion >= 1;\n    }\n  }, {\n    key: \"hasListCollectionsCommand\",\n    get: function get() {\n      return this.maxWireVersion >= 3;\n    }\n  }, {\n    key: \"hasListIndexesCommand\",\n    get: function get() {\n      return this.maxWireVersion >= 3;\n    }\n  }, {\n    key: \"supportsSnapshotReads\",\n    get: function get() {\n      return this.maxWireVersion >= 13;\n    }\n  }, {\n    key: \"commandsTakeWriteConcern\",\n    get: function get() {\n      return this.maxWireVersion >= 5;\n    }\n  }, {\n    key: \"commandsTakeCollation\",\n    get: function get() {\n      return this.maxWireVersion >= 5;\n    }\n  }]);\n\n  return ServerCapabilities;\n}();\n\nexports.ServerCapabilities = ServerCapabilities;","map":null,"metadata":{},"sourceType":"script"}