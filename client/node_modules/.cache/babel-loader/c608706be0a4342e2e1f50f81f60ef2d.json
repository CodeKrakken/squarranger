{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.commandSupportsReadConcern = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\n\nvar promise_provider_1 = require(\"./promise_provider\");\n\nvar bson_1 = require(\"./bson\");\n\nvar read_preference_1 = require(\"./read_preference\");\n\nvar transactions_1 = require(\"./transactions\");\n\nvar common_1 = require(\"./sdam/common\");\n\nvar shared_1 = require(\"./cmap/wire_protocol/shared\");\n\nvar error_1 = require(\"./error\");\n\nvar utils_1 = require(\"./utils\");\n\nvar execute_operation_1 = require(\"./operations/execute_operation\");\n\nvar run_command_1 = require(\"./operations/run_command\");\n\nvar connection_1 = require(\"./cmap/connection\");\n\nvar metrics_1 = require(\"./cmap/metrics\");\n\nvar mongo_types_1 = require(\"./mongo_types\");\n\nvar read_concern_1 = require(\"./read_concern\");\n\nvar minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    var error = new error_1.MongoExpiredSessionError();\n\n    if (typeof callback === 'function') {\n      callback(error);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n/** @internal */\n\n\nvar kServerSession = Symbol('serverSession');\n/** @internal */\n\nvar kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\n\nvar kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\n\nvar kPinnedConnection = Symbol('pinnedConnection');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\n\nvar ClientSession = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(ClientSession, _mongo_types_1$TypedE);\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param topology - The current client's topology (Internal Class)\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  function ClientSession(topology, sessionPool, options, clientOptions) {\n    var _this;\n\n    _classCallCheck(this, ClientSession);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClientSession).call(this));\n    /** @internal */\n\n    _this[_a] = false;\n\n    if (topology == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (options.snapshot === true) {\n      _this[kSnapshotEnabled] = true;\n\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n\n    _this.topology = topology;\n    _this.sessionPool = sessionPool;\n    _this.hasEnded = false;\n    _this.clientOptions = clientOptions;\n    _this[kServerSession] = undefined;\n    _this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n    _this.clusterTime = options.initialClusterTime;\n    _this.operationTime = undefined;\n    _this.explicit = !!options.explicit;\n    _this.owner = options.owner;\n    _this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    _this.transaction = new transactions_1.Transaction();\n    return _this;\n  }\n  /** The server id associated with this session */\n\n\n  _createClass(ClientSession, [{\n    key: \"pin\",\n\n    /** @internal */\n    value: function pin(conn) {\n      if (this[kPinnedConnection]) {\n        throw TypeError('Cannot pin multiple connections to the same session');\n      }\n\n      this[kPinnedConnection] = conn;\n      conn.emit(connection_1.Connection.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    }\n    /** @internal */\n\n  }, {\n    key: \"unpin\",\n    value: function unpin(options) {\n      if (this.loadBalanced) {\n        return maybeClearPinnedConnection(this, options);\n      }\n\n      this.transaction.unpinServer();\n    }\n  }, {\n    key: \"endSession\",\n    value: function endSession(options, callback) {\n      var _this2 = this;\n\n      if (typeof options === 'function') callback = options, options = {};\n\n      var finalOptions = _objectSpread({\n        force: true\n      }, options);\n\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        if (_this2.hasEnded) {\n          maybeClearPinnedConnection(_this2, finalOptions);\n          return done();\n        }\n\n        var completeEndSession = function completeEndSession() {\n          maybeClearPinnedConnection(_this2, finalOptions); // release the server session back to the pool\n\n          _this2.sessionPool.release(_this2.serverSession);\n\n          _this2[kServerSession] = undefined; // mark the session as ended, and emit a signal\n\n          _this2.hasEnded = true;\n\n          _this2.emit('ended', _this2); // spec indicates that we should ignore all errors for `endSessions`\n\n\n          done();\n        };\n\n        if (_this2.serverSession && _this2.inTransaction()) {\n          _this2.abortTransaction(function (err) {\n            if (err) return done(err);\n            completeEndSession();\n          });\n\n          return;\n        }\n\n        completeEndSession();\n      });\n    }\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n\n  }, {\n    key: \"advanceOperationTime\",\n    value: function advanceOperationTime(operationTime) {\n      if (this.operationTime == null) {\n        this.operationTime = operationTime;\n        return;\n      }\n\n      if (operationTime.greaterThan(this.operationTime)) {\n        this.operationTime = operationTime;\n      }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n\n  }, {\n    key: \"advanceClusterTime\",\n    value: function advanceClusterTime(clusterTime) {\n      var _b, _c;\n\n      if (!clusterTime || typeof clusterTime !== 'object') {\n        throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n      }\n\n      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n        throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n      }\n\n      if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?\n      ) {\n        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n      }\n\n      (0, common_1._advanceClusterTime)(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(session) {\n      if (!(session instanceof ClientSession)) {\n        return false;\n      }\n\n      if (this.id == null || session.id == null) {\n        return false;\n      }\n\n      return this.id.id.buffer.equals(session.id.id.buffer);\n    }\n    /** Increment the transaction number on the internal ServerSession */\n\n  }, {\n    key: \"incrementTransactionNumber\",\n    value: function incrementTransactionNumber() {\n      if (this.serverSession) {\n        this.serverSession.txnNumber = typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n      }\n    }\n    /** @returns whether this session is currently in a transaction or not */\n\n  }, {\n    key: \"inTransaction\",\n    value: function inTransaction() {\n      return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n\n  }, {\n    key: \"startTransaction\",\n    value: function startTransaction(options) {\n      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n      if (this[kSnapshotEnabled]) {\n        throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n      }\n\n      assertAlive(this);\n\n      if (this.inTransaction()) {\n        throw new error_1.MongoTransactionError('Transaction already in progress');\n      }\n\n      if (this.isPinned && this.transaction.isCommitted) {\n        this.unpin();\n      }\n\n      var topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.topology);\n\n      if ((0, shared_1.isSharded)(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n        throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n      } // increment txnNumber\n\n\n      this.incrementTransactionNumber(); // create transaction state\n\n      this.transaction = new transactions_1.Transaction({\n        readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n        writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n        readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n        maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n      });\n      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n  }, {\n    key: \"commitTransaction\",\n    value: function commitTransaction(callback) {\n      var _this3 = this;\n\n      return (0, utils_1.maybePromise)(callback, function (cb) {\n        return endTransaction(_this3, 'commitTransaction', cb);\n      });\n    }\n  }, {\n    key: \"abortTransaction\",\n    value: function abortTransaction(callback) {\n      var _this4 = this;\n\n      return (0, utils_1.maybePromise)(callback, function (cb) {\n        return endTransaction(_this4, 'abortTransaction', cb);\n      });\n    }\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n\n  }, {\n    key: \"toBSON\",\n    value: function toBSON() {\n      throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Runs a provided lambda within a transaction, retrying either the commit operation\n     * or entire transaction as needed (and when the error permits) to better ensure that\n     * the transaction can complete successfully.\n     *\n     * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n     * return a Promise will result in undefined behavior.\n     *\n     * @param fn - A lambda to run within a transaction\n     * @param options - Optional settings for the transaction\n     */\n\n  }, {\n    key: \"withTransaction\",\n    value: function withTransaction(fn, options) {\n      var startTime = (0, utils_1.now)();\n      return attemptTransaction(this, startTime, fn, options);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      var _b;\n\n      return (_b = this.serverSession) === null || _b === void 0 ? void 0 : _b.id;\n    }\n  }, {\n    key: \"serverSession\",\n    get: function get() {\n      if (this[kServerSession] == null) {\n        this[kServerSession] = this.sessionPool.acquire();\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      return this[kServerSession];\n    }\n    /** Whether or not this session is configured for snapshot reads */\n\n  }, {\n    key: \"snapshotEnabled\",\n    get: function get() {\n      return this[kSnapshotEnabled];\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.topology.description.type === common_1.TopologyType.LoadBalanced;\n    }\n    /** @internal */\n\n  }, {\n    key: \"pinnedConnection\",\n    get: function get() {\n      return this[kPinnedConnection];\n    }\n  }, {\n    key: \"isPinned\",\n    get: function get() {\n      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n  }]);\n\n  return ClientSession;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nvar MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nvar NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  var isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\n\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  var conn = session[kPinnedConnection];\n  var error = options === null || options === void 0 ? void 0 : options.error;\n\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel('TransientTransactionError')) {\n    return;\n  } // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n\n\n  if (conn) {\n    var servers = Array.from(session.topology.s.servers.values());\n    var loadBalancer = servers[0];\n\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(connection_1.Connection.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n\n      if (options === null || options === void 0 ? void 0 : options.forceClear) {\n        loadBalancer.s.pool.clear(conn.serviceId);\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(function (err) {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nvar USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  var Promise = promise_provider_1.PromiseProvider.get();\n  session.startTransaction(options);\n  var promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction();\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(function () {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, function (err) {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel('UnknownTransactionCommitResult');\n      }\n\n      throw err;\n    }\n\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(function () {\n        return maybeRetryOrThrow(err);\n      });\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  } // handle any initial problematic cases\n\n\n  var txnState = session.transaction.state;\n\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  var command = _defineProperty({}, commandName, 1); // apply a writeConcern if specified\n\n\n  var writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern: writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n      return callback();\n    }\n\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n\n    if (e) {\n      if (e instanceof error_1.MongoNetworkError || e instanceof error_1.MongoWriteConcernError || (0, error_1.isRetryableError)(e) || isMaxTimeMSExpiredError(e)) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult'); // per txns spec, must unpin session in this case\n\n          session.unpin({\n            error: e\n          });\n        }\n      } else if (e.hasErrorLabel('TransientTransactionError')) {\n        session.unpin({\n          error: e\n        });\n      }\n    }\n\n    callback(e, r);\n  } // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  (0, execute_operation_1.executeOperation)(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session: session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), function (err, reply) {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n\n    if (err && (0, error_1.isRetryableEndTransactionError)(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return (0, execute_operation_1.executeOperation)(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session: session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), function (_err, _reply) {\n        return commandHandler(_err, _reply);\n      });\n    }\n\n    commandHandler(err, reply);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\n\n\nvar ServerSession = /*#__PURE__*/function () {\n  /** @internal */\n  function ServerSession() {\n    _classCallCheck(this, ServerSession);\n\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n\n\n  _createClass(ServerSession, [{\n    key: \"hasTimedOut\",\n    value: function hasTimedOut(sessionTimeoutMinutes) {\n      // Take the difference of the lastUse timestamp and now, which will result in a value in\n      // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n      var idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n      return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n  }]);\n\n  return ServerSession;\n}();\n\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\n\nvar ServerSessionPool = /*#__PURE__*/function () {\n  function ServerSessionPool(topology) {\n    _classCallCheck(this, ServerSessionPool);\n\n    if (topology == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /** Ends all sessions in the session pool */\n\n\n  _createClass(ServerSessionPool, [{\n    key: \"endAllPooledSessions\",\n    value: function endAllPooledSessions(callback) {\n      var _this5 = this;\n\n      if (this.sessions.length) {\n        this.topology.endSessions(this.sessions.map(function (session) {\n          return session.id;\n        }), function () {\n          _this5.sessions = [];\n\n          if (typeof callback === 'function') {\n            callback();\n          }\n        });\n        return;\n      }\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    }\n    /**\n     * Acquire a Server Session from the pool.\n     * Iterates through each session in the pool, removing any stale sessions\n     * along the way. The first non-stale session found is removed from the\n     * pool and returned. If no non-stale session is found, a new ServerSession is created.\n     */\n\n  }, {\n    key: \"acquire\",\n    value: function acquire() {\n      var sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n\n      while (this.sessions.length) {\n        var session = this.sessions.shift();\n\n        if (session && (this.topology.loadBalanced || !session.hasTimedOut(sessionTimeoutMinutes))) {\n          return session;\n        }\n      }\n\n      return new ServerSession();\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(session) {\n      var sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n      if (this.topology.loadBalanced && !sessionTimeoutMinutes) {\n        this.sessions.unshift(session);\n      }\n\n      if (!sessionTimeoutMinutes) {\n        return;\n      }\n\n      while (this.sessions.length) {\n        var pooledSession = this.sessions[this.sessions.length - 1];\n\n        if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n          this.sessions.pop();\n        } else {\n          break;\n        }\n      }\n\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        if (session.isDirty) {\n          return;\n        } // otherwise, readd this session to the session pool\n\n\n        this.sessions.unshift(session);\n      }\n    }\n  }]);\n\n  return ServerSessionPool;\n}();\n\nexports.ServerSessionPool = ServerSessionPool; // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\n\nfunction applySession(session, command, options) {\n  var _b; // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n\n\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n\n  var serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  } // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n\n\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    if (session && session.explicit) {\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n\n    return;\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id; // first apply non-transaction-specific sessions data\n\n  var inTransaction = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  var isRetryableWrite = (options === null || options === void 0 ? void 0 : options.willRetryWrite) || false;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTransaction) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n\n    if (session.supports.causalConsistency && session.operationTime && commandSupportsReadConcern(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n\n    return;\n  } // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    var readConcern = session.transaction.options.readConcern || ((_b = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _b === void 0 ? void 0 : _b.readConcern);\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nexports.applySession = applySession;\n\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    var atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":null,"metadata":{},"sourceType":"script"}