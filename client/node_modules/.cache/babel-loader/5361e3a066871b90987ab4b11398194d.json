{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\n\nvar db_1 = require(\"./db\");\n\nvar change_stream_1 = require(\"./change_stream\");\n\nvar error_1 = require(\"./error\");\n\nvar utils_1 = require(\"./utils\");\n\nvar connect_1 = require(\"./operations/connect\");\n\nvar promise_provider_1 = require(\"./promise_provider\");\n\nvar bson_1 = require(\"./bson\");\n\nvar connection_string_1 = require(\"./connection_string\");\n\nvar mongo_types_1 = require(\"./mongo_types\");\n/** @public */\n\n\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\n\nvar kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\n\nvar MongoClient = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(MongoClient, _mongo_types_1$TypedE);\n\n  function MongoClient(url, options) {\n    var _this;\n\n    _classCallCheck(this, MongoClient);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MongoClient).call(this));\n    _this[kOptions] = (0, connection_string_1.parseOptions)(url, _assertThisInitialized(_assertThisInitialized(_this)), options); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    var client = _assertThisInitialized(_assertThisInitialized(_this)); // The internal state\n\n\n    _this.s = {\n      url: url,\n      sessions: new Set(),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(_this[kOptions]),\n      namespace: (0, utils_1.ns)('admin'),\n\n      get options() {\n        return client[kOptions];\n      },\n\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n\n      get logger() {\n        return client[kOptions].logger;\n      }\n\n    };\n    return _this;\n  }\n\n  _createClass(MongoClient, [{\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this2 = this;\n\n      if (callback && typeof callback !== 'function') {\n        throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n      }\n\n      return (0, utils_1.maybePromise)(callback, function (cb) {\n        (0, connect_1.connect)(_this2, _this2[kOptions], function (err) {\n          if (err) return cb(err);\n          cb(undefined, _this2);\n        });\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(forceOrCallback, callback) {\n      var _this3 = this;\n\n      if (typeof forceOrCallback === 'function') {\n        callback = forceOrCallback;\n      }\n\n      var force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n      return (0, utils_1.maybePromise)(callback, function (callback) {\n        if (_this3.topology == null) {\n          return callback();\n        } // clear out references to old topology\n\n\n        var topology = _this3.topology;\n        _this3.topology = undefined;\n        topology.close({\n          force: force\n        }, function (error) {\n          if (error) return callback(error);\n          var encrypter = _this3[kOptions].encrypter;\n\n          if (encrypter) {\n            return encrypter.close(_this3, force, function (error) {\n              callback(error);\n            });\n          }\n\n          callback();\n        });\n      });\n    }\n    /**\n     * Create a new Db instance sharing the current socket connections.\n     *\n     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n     * @param options - Optional settings for Db construction\n     */\n\n  }, {\n    key: \"db\",\n    value: function db(dbName, options) {\n      options = options !== null && options !== void 0 ? options : {}; // Default to db from connection string if not provided\n\n      if (!dbName) {\n        dbName = this.options.dbName;\n      } // Copy the options and add out internal override of the not shared flag\n\n\n      var finalOptions = Object.assign({}, this[kOptions], options); // Return the db object\n\n      var db = new db_1.Db(this, dbName, finalOptions); // Return the database\n\n      return db;\n    }\n  }, {\n    key: \"startSession\",\n    value: function startSession(options) {\n      options = Object.assign({\n        explicit: true\n      }, options);\n\n      if (!this.topology) {\n        throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n      }\n\n      return this.topology.startSession(options, this.s.options);\n    }\n  }, {\n    key: \"withSession\",\n    value: function withSession(optionsOrOperation, callback) {\n      var options = optionsOrOperation;\n\n      if (typeof optionsOrOperation === 'function') {\n        callback = optionsOrOperation;\n        options = {\n          owner: Symbol()\n        };\n      }\n\n      if (callback == null) {\n        throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n      }\n\n      var session = this.startSession(options);\n      var Promise = promise_provider_1.PromiseProvider.get();\n\n      var _cleanupHandler = function cleanupHandler(err, result, opts) {\n        // prevent multiple calls to cleanupHandler\n        _cleanupHandler = function cleanupHandler() {\n          // TODO(NODE-3483)\n          throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n        };\n\n        opts = Object.assign({\n          throw: true\n        }, opts);\n        session.endSession();\n\n        if (err) {\n          if (opts.throw) throw err;\n          return Promise.reject(err);\n        }\n      };\n\n      try {\n        var result = callback(session);\n        return Promise.resolve(result).then(function (result) {\n          return _cleanupHandler(undefined, result, undefined);\n        }, function (err) {\n          return _cleanupHandler(err, null, {\n            throw: true\n          });\n        });\n      } catch (err) {\n        return _cleanupHandler(err, null, {\n          throw: false\n        });\n      }\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this cluster. Will ignore all\n     * changes to system collections, as well as the local, admin, and config databases.\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     */\n\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // Allow optionally not specifying a pipeline\n      if (!Array.isArray(pipeline)) {\n        options = pipeline;\n        pipeline = [];\n      }\n\n      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /** Return the mongo client logger */\n\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.s.logger;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return Object.freeze(_objectSpread({}, this[kOptions]));\n    }\n  }, {\n    key: \"serverApi\",\n    get: function get() {\n      return this[kOptions].serverApi && Object.freeze(_objectSpread({}, this[kOptions].serverApi));\n    }\n    /**\n     * Intended for APM use only\n     * @internal\n     */\n\n  }, {\n    key: \"monitorCommands\",\n    get: function get() {\n      return this[kOptions].monitorCommands;\n    },\n    set: function set(value) {\n      this[kOptions].monitorCommands = value;\n    }\n  }, {\n    key: \"autoEncrypter\",\n    get: function get() {\n      return this[kOptions].autoEncrypter;\n    }\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      return this.s.readConcern;\n    }\n  }, {\n    key: \"writeConcern\",\n    get: function get() {\n      return this.s.writeConcern;\n    }\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      return this.s.readPreference;\n    }\n  }, {\n    key: \"bsonOptions\",\n    get: function get() {\n      return this.s.bsonOptions;\n    }\n  }, {\n    key: \"logger\",\n    get: function get() {\n      return this.s.logger;\n    }\n  }], [{\n    key: \"connect\",\n    value: function connect(url, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n\n      try {\n        // Create client\n        var mongoClient = new MongoClient(url, options); // Execute the connect method\n\n        if (callback) {\n          return mongoClient.connect(callback);\n        } else {\n          return mongoClient.connect();\n        }\n      } catch (error) {\n        if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n      }\n    }\n  }]);\n\n  return MongoClient;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.MongoClient = MongoClient;","map":null,"metadata":{},"sourceType":"script"}