{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = void 0;\n\nvar utils_1 = require(\"../utils\");\n\nvar common_1 = require(\"./common\");\n\nvar bson_1 = require(\"../bson\");\n\nvar WRITABLE_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.Standalone, common_1.ServerType.Mongos, common_1.ServerType.LoadBalancer]);\nvar DATA_BEARING_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.RSSecondary, common_1.ServerType.Mongos, common_1.ServerType.Standalone, common_1.ServerType.LoadBalancer]);\n/**\n * The client's view of a single server, based on the most recent ismaster outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\n\nvar ServerDescription = /*#__PURE__*/function () {\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param ismaster - An optional ismaster response for this server\n   */\n  function ServerDescription(address, ismaster, options) {\n    _classCallCheck(this, ServerDescription);\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n\n    if (typeof address === 'string') {\n      this._hostAddress = new utils_1.HostAddress(address);\n      this.address = this._hostAddress.toString();\n    } else {\n      this._hostAddress = address;\n      this.address = this._hostAddress.toString();\n    }\n\n    this.type = parseServerType(ismaster, options);\n    this.hosts = (_b = (_a = ismaster === null || ismaster === void 0 ? void 0 : ismaster.hosts) === null || _a === void 0 ? void 0 : _a.map(function (host) {\n      return host.toLowerCase();\n    })) !== null && _b !== void 0 ? _b : [];\n    this.passives = (_d = (_c = ismaster === null || ismaster === void 0 ? void 0 : ismaster.passives) === null || _c === void 0 ? void 0 : _c.map(function (host) {\n      return host.toLowerCase();\n    })) !== null && _d !== void 0 ? _d : [];\n    this.arbiters = (_f = (_e = ismaster === null || ismaster === void 0 ? void 0 : ismaster.arbiters) === null || _e === void 0 ? void 0 : _e.map(function (host) {\n      return host.toLowerCase();\n    })) !== null && _f !== void 0 ? _f : [];\n    this.tags = (_g = ismaster === null || ismaster === void 0 ? void 0 : ismaster.tags) !== null && _g !== void 0 ? _g : {};\n    this.minWireVersion = (_h = ismaster === null || ismaster === void 0 ? void 0 : ismaster.minWireVersion) !== null && _h !== void 0 ? _h : 0;\n    this.maxWireVersion = (_j = ismaster === null || ismaster === void 0 ? void 0 : ismaster.maxWireVersion) !== null && _j !== void 0 ? _j : 0;\n    this.roundTripTime = (_k = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _k !== void 0 ? _k : -1;\n    this.lastUpdateTime = (0, utils_1.now)();\n    this.lastWriteDate = (_m = (_l = ismaster === null || ismaster === void 0 ? void 0 : ismaster.lastWrite) === null || _l === void 0 ? void 0 : _l.lastWriteDate) !== null && _m !== void 0 ? _m : 0;\n\n    if (options === null || options === void 0 ? void 0 : options.topologyVersion) {\n      this.topologyVersion = options.topologyVersion;\n    } else if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.topologyVersion) {\n      this.topologyVersion = ismaster.topologyVersion;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.error) {\n      this.error = options.error;\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.primary) {\n      this.primary = ismaster.primary;\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.me) {\n      this.me = ismaster.me.toLowerCase();\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.setName) {\n      this.setName = ismaster.setName;\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.setVersion) {\n      this.setVersion = ismaster.setVersion;\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.electionId) {\n      this.electionId = ismaster.electionId;\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.logicalSessionTimeoutMinutes) {\n      this.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;\n    }\n\n    if (ismaster === null || ismaster === void 0 ? void 0 : ismaster.$clusterTime) {\n      this.$clusterTime = ismaster.$clusterTime;\n    }\n  }\n\n  _createClass(ServerDescription, [{\n    key: \"equals\",\n\n    /**\n     * Determines if another `ServerDescription` is equal to this one per the rules defined\n     * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n     */\n    value: function equals(other) {\n      var topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;\n      var electionIdsEqual = this.electionId && other.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId;\n      return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;\n    }\n  }, {\n    key: \"hostAddress\",\n    get: function get() {\n      if (this._hostAddress) return this._hostAddress;else return new utils_1.HostAddress(this.address);\n    }\n  }, {\n    key: \"allHosts\",\n    get: function get() {\n      return this.hosts.concat(this.arbiters).concat(this.passives);\n    }\n    /** Is this server available for reads*/\n\n  }, {\n    key: \"isReadable\",\n    get: function get() {\n      return this.type === common_1.ServerType.RSSecondary || this.isWritable;\n    }\n    /** Is this server data bearing */\n\n  }, {\n    key: \"isDataBearing\",\n    get: function get() {\n      return DATA_BEARING_SERVER_TYPES.has(this.type);\n    }\n    /** Is this server available for writes */\n\n  }, {\n    key: \"isWritable\",\n    get: function get() {\n      return WRITABLE_SERVER_TYPES.has(this.type);\n    }\n  }, {\n    key: \"host\",\n    get: function get() {\n      var chopLength = \":\".concat(this.port).length;\n      return this.address.slice(0, -chopLength);\n    }\n  }, {\n    key: \"port\",\n    get: function get() {\n      var port = this.address.split(':').pop();\n      return port ? Number.parseInt(port, 10) : 27017;\n    }\n  }]);\n\n  return ServerDescription;\n}();\n\nexports.ServerDescription = ServerDescription; // Parses an `ismaster` message and determines the server type\n\nfunction parseServerType(ismaster, options) {\n  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {\n    return common_1.ServerType.LoadBalancer;\n  }\n\n  if (!ismaster || !ismaster.ok) {\n    return common_1.ServerType.Unknown;\n  }\n\n  if (ismaster.isreplicaset) {\n    return common_1.ServerType.RSGhost;\n  }\n\n  if (ismaster.msg && ismaster.msg === 'isdbgrid') {\n    return common_1.ServerType.Mongos;\n  }\n\n  if (ismaster.setName) {\n    if (ismaster.hidden) {\n      return common_1.ServerType.RSOther;\n    } else if (ismaster.ismaster || ismaster.isWritablePrimary) {\n      return common_1.ServerType.RSPrimary;\n    } else if (ismaster.secondary) {\n      return common_1.ServerType.RSSecondary;\n    } else if (ismaster.arbiterOnly) {\n      return common_1.ServerType.RSArbiter;\n    } else {\n      return common_1.ServerType.RSOther;\n    }\n  }\n\n  return common_1.ServerType.Standalone;\n}\n\nexports.parseServerType = parseServerType;\n\nfunction tagsStrictEqual(tags, tags2) {\n  var tagsKeys = Object.keys(tags);\n  var tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(function (key) {\n    return tags2[key] === tags[key];\n  });\n}\n/**\n * Compares two topology versions.\n *\n * @returns A negative number if `lhs` is older than `rhs`; positive if `lhs` is newer than `rhs`; 0 if they are equivalent.\n */\n\n\nfunction compareTopologyVersion(lhs, rhs) {\n  if (lhs == null || rhs == null) {\n    return -1;\n  }\n\n  if (lhs.processId.equals(rhs.processId)) {\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    var lhsCounter = bson_1.Long.isLong(lhs.counter) ? lhs.counter : bson_1.Long.fromNumber(lhs.counter);\n    var rhsCounter = bson_1.Long.isLong(rhs.counter) ? lhs.counter : bson_1.Long.fromNumber(rhs.counter);\n    return lhsCounter.compare(rhsCounter);\n  }\n\n  return -1;\n}\n\nexports.compareTopologyVersion = compareTopologyVersion;","map":null,"metadata":{},"sourceType":"script"}