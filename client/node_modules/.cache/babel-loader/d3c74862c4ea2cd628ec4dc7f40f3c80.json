{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/pea/Code/squarranger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\n\nvar net = require(\"net\");\n\nvar tls = require(\"tls\");\n\nvar connection_1 = require(\"./connection\");\n\nvar error_1 = require(\"../error\");\n\nvar defaultAuthProviders_1 = require(\"./auth/defaultAuthProviders\");\n\nvar auth_provider_1 = require(\"./auth/auth_provider\");\n\nvar utils_1 = require(\"../utils\");\n\nvar constants_1 = require(\"./wire_protocol/constants\");\n\nvar bson_1 = require(\"../bson\");\n\nvar FAKE_MONGODB_SERVICE_ID = typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' && process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\n\nfunction connect(options, callback) {\n  makeConnection(options, function (err, socket) {\n    var _a;\n\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    var ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(ismaster, options) {\n  var _a;\n\n  var serverVersionHighEnough = ismaster && (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof bson_1.Int32) && ismaster.maxWireVersion >= constants_1.MIN_SUPPORTED_WIRE_VERSION;\n  var serverVersionLowEnough = ismaster && (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof bson_1.Int32) && ismaster.minWireVersion <= constants_1.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    var _message = \"Server at \".concat(options.hostAddress, \" reports minimum wire version \").concat(JSON.stringify(ismaster.minWireVersion), \", but this version of the Node.js Driver requires at most \").concat(constants_1.MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(constants_1.MAX_SUPPORTED_SERVER_VERSION, \")\");\n\n    return new error_1.MongoCompatibilityError(_message);\n  }\n\n  var message = \"Server at \".concat(options.hostAddress, \" reports maximum wire version \").concat((_a = JSON.stringify(ismaster.maxWireVersion)) !== null && _a !== void 0 ? _a : 0, \", but this version of the Node.js Driver requires at least \").concat(constants_1.MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(constants_1.MIN_SUPPORTED_SERVER_VERSION, \")\");\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  var callback = function callback(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  var credentials = options.credentials;\n\n  if (credentials) {\n    if (!(credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT) && !defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(\"AuthMechanism '\".concat(credentials.mechanism, \"' not supported\")));\n      return;\n    }\n  }\n\n  var authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, function (err, handshakeDoc) {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    var handshakeOptions = Object.assign({}, options);\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    var start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, function (err, response) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n\n      if ('isWritablePrimary' in response) {\n        // Provide pre-hello-style response document.\n        response.ismaster = response.isWritablePrimary;\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      var supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        // TODO: Durran: Remove when server support exists. (NODE-3431)\n        if (FAKE_MONGODB_SERVICE_ID) {\n          response.serviceId = response.topologyVersion.processId;\n        }\n\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        var resolvedCredentials = credentials.resolveAuthMechanism(response);\n        var provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(resolvedCredentials.mechanism, \" defined.\")));\n        }\n\n        provider.auth(authContext, function (err) {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  var _handshakeDoc;\n\n  var options = authContext.options;\n  var compressors = options.compressors ? options.compressors : [];\n  var serverApi = authContext.connection.serverApi;\n  var handshakeDoc = (_handshakeDoc = {}, _defineProperty(_handshakeDoc, (serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : 'ismaster', true), _defineProperty(_handshakeDoc, \"helloOk\", true), _defineProperty(_handshakeDoc, \"client\", options.metadata || (0, utils_1.makeClientMetadata)(options)), _defineProperty(_handshakeDoc, \"compression\", compressors), _defineProperty(_handshakeDoc, \"loadBalanced\", options.loadBalanced), _handshakeDoc);\n  var credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = \"\".concat(credentials.source, \".\").concat(credentials.username);\n\n      var _provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n      if (!_provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256, \" defined.\")));\n      }\n\n      return _provider.prepare(handshakeDoc, authContext, callback);\n    }\n\n    var provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism);\n\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(credentials.mechanism, \" defined.\")));\n    }\n\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n\n  callback(undefined, handshakeDoc);\n}\n/** @public */\n\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  var hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  var result = {};\n\n  var _iterator = _createForOfIteratorHelper(exports.LEGAL_TCP_SOCKET_OPTIONS),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var name = _step.value;\n\n      if (options[name] != null) {\n        result[name] = options[name];\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(\"Unexpected HostAddress \".concat(JSON.stringify(hostAddress)));\n  }\n}\n\nfunction parseSslOptions(options) {\n  var result = parseConnectOptions(options); // Merge in valid SSL options\n\n  var _iterator2 = _createForOfIteratorHelper(exports.LEGAL_TLS_SOCKET_OPTIONS),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var name = _step2.value;\n\n      if (options[name] != null) {\n        result[name] = options[name];\n      }\n    } // Set default sni servername to be the same as host\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nvar SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nvar SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  var useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  var keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  var socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  var noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  var connectionTimeout = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  var rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  var keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  var socket;\n\n  var callback = function callback(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (useTLS) {\n    var tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  var connectEvent = useTLS ? 'secureConnect' : 'connect';\n  var cancellationHandler;\n\n  function errorHandler(eventName) {\n    return function (err) {\n      SOCKET_ERROR_EVENTS.forEach(function (event) {\n        return socket.removeAllListeners(event);\n      });\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(function (event) {\n      return socket.removeAllListeners(event);\n    });\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(function (event) {\n    return socket.once(event, errorHandler(event));\n  });\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}